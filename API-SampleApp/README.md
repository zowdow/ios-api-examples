zowdow-sdk-ios
==============

How to quickly create a new build
---------------------------------
### Of the SDK
Go to this [ZowdowSDK-iOS Jenkins job](http://jenkins.buildserver.mobi:8080/view/ZowDow/job/ZowdowSDK-iOS/build?delay=0sec).  To build `master` branch: choose `BRANCH=master`, `CONFIGURATION=sdk` (that's the default anyway).  To build `legacy` branch: choose `BRANCH=legacy`, `CONFIGURATION=universalLib`. 

### Of the Alpha app
Go to [Zowdow-Alpha-iOS Jenkins job](http://jenkins.buildserver.mobi:8080/view/ZowDow/job/Zowdow-Alpha-iOS/build?delay=0sec).  Choose the branch you need to build and the configuration: `adhoc` or `pod_integration`.  The first will integrate `ZowdowSDK` as a subproject, and the latter will use a cocoapod we distribute via `podspecs_staging`.  But remember - it does not do `pod update` step for you - so you need to do it manually prior to building, commit and push, because we store CocoaPods in the repository!

Directory structure
-------------------

`ZowdowSDK` directory contains the library code, project file, together with the scripts to build it  

`Prototype.xcworkspace` is the workspace which hosts the prototype app (aka `The [iOS] Demo App`)

`SDKTests` contains the unit tests for the SDK

Building and distributing the SDK
---------------------------------
ZowdowSDK project contains targets: 
- `ZowdowSDK` (builds SDK static library)
- `ZowdowSDKResources` (a separate target to compile the resources into a resource bundle)
- `MangleNames` (a target whose sole purpose is to output `NamespacedDependencies.h` header)
- `BuildAndPublishZip` (gathers all artifacts into a zip package, uploads it to S3 and publishes cocoapod)

Dependency name mangling
------------------------
SDK depends on 
- AFNetworking
- Mantle
- FMDB
- ...

### The Why
When SDK is integrated into the client app - we should prevent name collisions during linking.
In case the client app uses the same dependency library as the SDK (f.e. AFNetworking) 
- we will get duplicate symbols during linking, because the symbol will be defined twice 
coming from the client app object files and from the static library (which is basically an
object file).  To prevent this we use automatic name mangling.

### The How
Since we integrate dependencies in the form of source code - we use C macros which replace the original name of the dependency with the namespaced one.  F.e.:

```
#define AFHTTPRequestManager Zowdow_AFHTTPRequestManager
```

Of course if we had to do all these declarations by hand - it would be too tedious and unmaintanable, instead file `NamespacedDependencies.h` is generated by running the target `MangleNames` - it takes all the dependency symbols and provides defines with prefixed rewrites.

So whenever you add a new dependency - add it to `MangleNames` target, but when you add a file to the SDK code - don't add it `into MangleNames` dependency.  After adding a dependency build `MangleNames` to generate the new `NamespacedDependencies.h`. 

Versioning
----------
The ZowdowSDK version is set in the ZowdowSDK project build settings via the DYLIB_CURRENT_VERSION flag.  Then during build we generate `Version.h` header which contains this version string value and implants it into the SDK. 

The SDK version has to be incremented manually for now.  We haven't come up with automating this step yet.  You increment the DYLIB_CURRENT_VERSION flag, then you build the SDK - it will generate Version.h

Distribution
------------
SDK is packaged into a zip archive (`BuildAndPublishZip` target does this) and it is possible to integrate it either directly using drag & drop or using cocoapods.  

The Prototype app (or Alpha app) comes in two flavors:
- dev scenario - where we link to the SDK directly as a subproject.  
- pod integration - where we link to the SDK using cocoapods - as if prototype is some kind of example app.

This latter scenario allows us to test the SDK as it would be integrated in the client app.  Allows us to catch some weird bugs that would not be detected when we integrate it as a subproject.  However it comes with an overhead.  

To build `pod_integration` configuration - we first need to publish the updated version of the SDK - it automatically uploads to S3 and publishes a podspec in `podspecs_staging` repository.  

Then we need to run `pod update` on the prototype app - this will update the `Prototype` app with the latest pod - and then we can commit this change and distribute the `Prototype` build via HockeyApp f.e.
